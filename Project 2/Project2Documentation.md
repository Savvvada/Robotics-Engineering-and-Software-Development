This folder encapsulates all the files necessary to run "ScoutBot" my second project. For my second project, project 2, I intended to create a scout-like or surveying algorithm. One which detects objects via the distance sensor then takes a picture in that direction and subsequently draws circles in areas of detections. These steps are performed as the GoPiGo rotates in ~10-degree intervals(it has been set to 12 as sometimes when the battery is low the power to the motor for a 10-degree turn is presumably undervolted) before proceeding to visit each detected object one by one regardless of their configuration about the GoPIGo. This was Initially designed to detect apples within the range of 100 centimeters from the robot to attempt to demonstrate the automation potential of an aspect of agriculture, which would be, collecting and logging data of ripened fruit. Although initial success was encountered through using yoloV3 alone to detect apples, incorporating it into an algorithm on the GoPiGo proved difficult since the standard yoloV3 model has high resource demands on the Raspberry Pi. In hindsight, if I were to re-attempt this project I would opt for yoloV3-tiny or YoloV2, as they are lighter and faster. Regardless, the algorithm still fulfills a considerable amount of its original function. To start with, it still takes snapshots within a certain distance and processes it through YoloV3, outputting two images: a before with no cv2 text or drawings, and a second with a circle centered at the detected object and text which displays its polar coordinates. Also, the final product of the result still ends with the GoPiGo3  visiting each object in various configurations, albeit there are at times discrepancies between the objects expected distance from the robots current location ( calculated with the "calcshortest" function, via trigonometry and the distance formula for polar coordinates) and the expected distance of the next nearest object. Due to this, the objects the GoPiGo visits and registers must be equidistant from each other, although they can form any shape desired. The robot's current location is determined through the "whereAt" variable. As every object is a node on a doubly-linked-list, the "whereAt" points to the last visited node, which would indicate the GoPiGo's current location. A blindspot in my conceptual design which relied heavily on the distance sensor, was the now obvious constraint on the space required so that the GoPiGo does not get a false positive of the desired object by something else in the environment satisfying the expected distance condition within the while loop of the "searchnext" function. Also, as mentioned earlier Yolov3 can be somewhat finicky on the GoPIGo3 as it would return completely false positives when trying to detect an apple specifically at times when the battery approached lower capacities. Although, at other times it would work just fine. However the detection was not consistent enough to be reliable, so instead the algorithm is set to detect all 80+ different objects in the "coco.names" file. This has proven to be successful regardless of battery levels. My speculation on this is that due to yoloV3  weights are preferential to tangible 3d objects while, when attempting to detect apples I used printed paper, so maybe some vectors between the two models are considerably different. A more likely possibility is instead my declaration of the object that should be detected in the initialization of the "EyeThread" is flawed, and I've made an error somewhere down the line of incorporating it into the program. Finally, although my implementation would be particularly demanding if not for the use of multi-threading, it works but takes an extremely long time to start if a change had been made. So much so, that in my demonstration video one can see a pycache file that was automatically generated to make running the program much faster. In correlation, as alluded to earlier, because of its high demand as the battery level drops, the motors become undervolted resulting in less than 360 degree turns, and in some cases, the program halts perpetually after a random amount of turns. Finally, through this personal project, I learned multidimensional skills and tools of utility in robotics and engineering that I hope to reinforce through later projects. This has been extremely fun to do, as it's been my first time working with robots, albeit I've become enamoured with them. My long-held initial goal of creating something that can be used in agriculture for nations across the world is still far from my reach, however, I feel I've become ever so closer to it and will continue to pursue it.
